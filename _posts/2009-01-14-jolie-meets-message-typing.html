---
layout: post
title: JOLIE meets Message Typing!
date: '2009-01-14T19:00:00.006+01:00'
author: Fabrizio Montesi
tags: 
modified_time: '2009-01-14T19:59:26.225+01:00'
blogger_id: tag:blogger.com,1999:blog-3856624862131672592.post-8942527156906402809
blogger_orig_url: http://fmontesi.blogspot.com/2009/01/jolie-meets-message-typing.html
---

I've just finished to adapt and merge into <a href="http://www.jolie-lang.org/">Jolie</a>'s SVN the awesome work derived from <a href="http://www.elvisciotti.it/blog/2008/12/tesi-sistema-di-tipi-per-jolie/">Elvis Ciotti's thesis</a>. The job required some time, but we are definitely improving our development process with people that decide to make a thesis on JOLIE (it required much more than a day in the past); I think that we can improve even more, but that's another story. Elvis made some testing scripts, too, so I'm pretty sure that my refactoring did not introduce any regression and testing the result was a painless process. Way to go, Elvis. =)<br /><br />So, message typing: what's that? Let's have a preface and then look at an example!<br /><br /><h2>The problem</h2><br />In a service-oriented world applications communicate with each other. An application (say, A) can communicate with another one (say, B) by using the interface exposed by the latter. An example of an interface is "I accept messages for an operation called <span style="font-weight: bold;">sum</span>. You shall send me two numbers and I will return their sum to you.".<br />The problem here is that A and B are completely separated applications. They could even have been made with different programming languages. What does assure us that A is gonna respect the interface specs of B? Unfortunately, nothing does. We do not have any means to do that, as A is a black box to our eyes: we can not peek inside. We can only hope A has been statically checked against our interface before being run, or that A hasn't been purposefully made wrong to mess B up.<br /><br />So what can we do?<br /><br />When B receives a message, it could check at run-time that it conforms to the interface. If not, it should discard it immediately. That way we are sure to be safe, and that B's internal program doesn't get unexpected data.<br /><br /><h2>Example</h2><br />Let us implement B with Jolie's syntax for message types. The code would look as the following:<br /><br /><pre><br />type SumRequest:void {<br />   .x:int<br />   .y:int<br />}<br /><br />inputPort B {<br />Location: "socket://localhost:8000"<br />Protocol: sodep<br />RequestResponse:<br />   sum(SumRequest)(int)<br />}<br /><br />main {<br />   sum( request )( result ) {<br />       result = request.x + request.y<br />   }<br />}<br /></pre><br /><br />In the example B accepts messages containing two sub-nodes, x and y. An XML representation of a valid message is the following:<br /><br /><pre><br />&lt;request&gt;<br />   &lt;x&gt;5&lt;/x&gt;<br />   &lt;y&gt;10&lt;/y&gt;<br />&lt;/request&gt;<br /></pre><br /><br />Jolie will take care that B doesn't receive anything that doesn't conform to SumRequestType. Clients sending a malformed message would receive a "TypeMismatch" fault in return.<br /><br />Jolie types are pretty expressive, you can also play with the number of occurrencies. An example of a more complex type:<br /><br /><pre><br />// A type describing an article<br />type Article {<br /><br />// We want at least one author, but no upper limit<br />   .author[1,*]:void {<br />       .name:string<br />       .surname:string<br />       .age:int<br />   }<br /><br />// We accept from 5 to 15 pages<br />   .page[5,15]:string<br /><br />// ? is a shortcut for [0,1], i.e. giving a summary is optional<br />   .summary?:string<br /><br />/* .metadata is left completely free,<br /> * type checking is not performed on it<br /> */<br />   .metadata:any { ? }<br />}<br /></pre><br /><br />The code has just entered so it still may have some bugs, but it works already with some advanced tests I've conducted with current SVN.<br /><br />Enjoy! =)