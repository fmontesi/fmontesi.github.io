---
layout: post
title: A little story about getting along with innovation
date: '2009-01-30T13:38:00.006+01:00'
author: Fabrizio Montesi
tags: 
modified_time: '2009-01-30T16:47:10.165+01:00'
blogger_id: tag:blogger.com,1999:blog-3856624862131672592.post-8500506443230185767
---

I was thinking about making such a post a year ago, but never found the motivation and the time to write it down. Today, <a href="http://aseigo.blogspot.com/2009/01/i-will-remain-in-spite-of-you.html">Aaron's post</a> reminded me about that thought and I have some time now, so here I am writing.<br /><br />This is all based upon my experience. I'm also probably missing a lot of things, because this topic is not easy. If you're a software engineer you might get bored by reading this (or not ;).<br /><br /><h1>Software projects and innovation</h1><br />There are two kinds of software projects with respect to innovation.<br /><br />The first kind is represented by software projects that are very specific in their scope and implementative requirements, focused on doing a few things well and reach stability soon.<br /><br />The second kind is represented by software projects that continuously meet new problems, even after becoming stable. Those projects inherently need to innovate themselves in order to bring solutions to the problems they meet.<br /><br />The rest of this post is about the second kind.<br /><br /><h1>Evolutionary vs Revolutionary innovation</h1><br />Innovation is necessary, because if you do not innovate you do not bring solutions to the problems you meet. But once you decide to innovate, a whole new set of problems appears before you.<br /><br /><h2>Evolutionary innovation</h2><br />Maybe your software project structure offers solid basis for the introduction of the solution. The factors that determine this are various, and fall out of the scope of this post. It's sufficient to say that the best situation is when introducing the solution does not interfere with the functioning of any other component of the software and does not imply the modification of any other component of the software. A bad situation is when, to introduce the solution, you're compelled to change a lot of things in other modules of your software project.<br /><br />If you have a structure ready to accept the implementation of the solution, you can follow an evolutionary approach. You simply change your software so that it has the new solution you want to add.<br /><br /><h2>Revolutionary approach</h2><br />Maybe your software structure does not offer solid basis for the implementation of the solution you need. That's a very common problem. There's a problem in the structure, and you'd be to implement the solution you'd need to make some "dirty hacks" or to change the code of a lot of components in your project. To use software engineering terms, you're losing module cohesion and shifting towards tighly coupled components.<br />You could simply "hack in" the solution without caring at the state of your software, but that's a bad idea. Do that, and your project will soon be in an unmaintanable state.<br /><br />You now face two choices: change your software structure or implement a different solution.<br />If you go for the first option (probably because the second option is not possible), you're going towards a revolution of your software. Making heavy changes to the structure of your project is going to be troublesome: a lot of features will break, bugs will come up, components will have to adapt to the new structure (and its new interfaces), even entire modules could enter in such a non-functional state that you will decide that it's better to rewrite them from scratch.<br /><br />There is a bright side in all this.<br />Software engineering depends *heavily* on experience. When someone recognizes that a revolutionary change needs to be done, that someone usually has gained some experience since his/her writing of the last structure. Your next software structure will probably be better for that.<br />Another important factor is that revolutionary changes can be made necessary by changes in the external world. The software world innovates itself particularly quickly. Your software could gain some serious benefits from adapting to external innovation, but adapting to them could require a revolution in your project structure.<br /><br />To sum it up, it's going to be a blood bath. But if you can go all the way until the end, the results will be worth it.<br /><br />